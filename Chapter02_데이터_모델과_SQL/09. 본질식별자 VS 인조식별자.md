# 📘 본질식별자(Essential Identifier) vs 인조식별자(Surrogate Identifier)

---

## 1️⃣ 개요

* **본질식별자와 인조식별자**는
  ✅ **데이터 모델링 시 주식별자(PK)를 구성하는 방식**에 따라 구분된다.
* 이 내용은 **2024년부터 SQLD 시험 범위에 새로 추가된 부분**이다.

---

## 2️⃣ 본질식별자 (Natural Identifier)

| 항목    | 내용                           |
| :---- | :--------------------------- |
| 정의    | 업무에서 **원래 존재하던 식별자**         |
| 특징    | 실제 비즈니스에서 사용되는 고유값           |
| 예시    | 사원번호, 학번, 주민등록번호, 계좌번호 등     |
| 생성 방식 | 실무에서 이미 존재하는 값 사용            |
| 장점    | 현실 데이터와 일치, 중복 방지, 무결성 유지 쉬움 |
| 단점    | 복합키가 되면 복잡해질 수 있음            |

> 💡 **핵심 요약**
> 본질식별자는 **업무적으로 이미 존재하는 고유 식별자**다.

---

## 3️⃣ 인조식별자 (Surrogate Identifier)

| 항목    | 내용                                                    |
| :---- | :---------------------------------------------------- |
| 정의    | **업무에는 존재하지 않지만**, 시스템 편의를 위해 **인위적으로 생성한 식별자**       |
| 생성 방식 | DBMS의 **시퀀스(Sequence)**, **Auto Increment** 등으로 자동 생성 |
| 예시    | 주문목록번호, 일련번호(ID), 내부용 PK                              |
| 등장 배경 | 복합식별자가 너무 복잡할 때 단일화하기 위해 도입                           |
| 장점    | 개발 및 관리가 편리, 속도 빠름, 코드 단순                             |
| 단점    | 데이터 중복 가능성 ↑, 인덱스 추가 필요, 현실 데이터와 불일치 가능               |

> 💡 **핵심 요약**
> 인조식별자는 **시스템 편의성 때문에 새로 만든 PK**다.
> 실제 업무에서는 존재하지 않는 값이다.

---

## 4️⃣ 예시 비교

| 구분       | 테이블 구성            | PK 구성 | 비고              |
| :------- | :---------------- | :---- | :-------------- |
| 본질식별자 사용 | 주문목록(주문번호 + 도서번호) | 복합 PK | 실제 업무 식별자 사용    |
| 인조식별자 사용 | 주문목록(목록번호)        | 단일 PK | 업무에는 없는 인위적 식별자 |

---

### 📍 예시 SQL

#### (1) 본질식별자 사용

```sql
CREATE TABLE 주문목록 (
    주문번호 INT,
    도서번호 INT,
    PRIMARY KEY (주문번호, 도서번호)
);
```

* **장점**: 중복 입력 방지, 무결성 유지, 인덱스 자동 생성
* **단점**: 복합키로 인해 관리 복잡

#### (2) 인조식별자 사용

```sql
CREATE TABLE 주문목록 (
    목록번호 INT PRIMARY KEY,
    주문번호 INT,
    도서번호 INT
);
```

* **장점**: 개발 편의성, 시퀀스로 자동 생성 가능
* **단점**: 데이터 중복 방지 어려움, 인덱스 직접 추가 필요

---

## 5️⃣ 장단점 비교 정리

| 구분      | 본질식별자           | 인조식별자       |
| :------ | :-------------- | :---------- |
| 생성 방식   | 실무 존재 데이터       | 시스템에서 자동 생성 |
| 복잡도     | 복합키일 수 있음       | 단일키로 단순함    |
| 개발 편의성  | 불편 (연산 多)       | 편리 (자동 생성)  |
| 중복 방지   | DB 제약조건으로 자동 방지 | 별도 제약 필요    |
| 인덱스     | 자동 생성           | 직접 생성 필요    |
| 데이터 무결성 | 강함              | 상대적으로 약함    |

---

## 6️⃣ 인조식별자 사용 이유

> 🔹 복합식별자가 너무 복잡할 때
> 🔹 개발 편의성을 높이기 위해
> 🔹 시퀀스나 자동 증가(AUTO_INCREMENT)로 쉽게 관리 가능
> 🔹 개발 시간 단축 → 비용 절감

---

## 7️⃣ 인조식별자 사용 시 주의점

* **데이터 중복 가능성** → 제약조건 또는 유니크 인덱스로 관리
* **인덱스 자동 생성 안 됨** → 직접 생성해야 함
* **현실 데이터와의 연결 고려** → 외래키 설계 시 주의
* **성능 저하 방지** → 조회 조건에 필요한 인덱스 별도 생성

---

## 8️⃣ 결론

| 요약    | 설명                                   |
| :---- | :----------------------------------- |
| 본질식별자 | 업무상 이미 존재하는 자연스러운 식별자                |
| 인조식별자 | 복잡한 식별자를 단순화하기 위해 인위적으로 만든 식별자       |
| 선택 기준 | 상황에 따라 다름. **편의성 vs 무결성** 균형 고려      |
| 최종 결론 | “인조식별자는 개발 편의성을 높이지만, 신중하게 선택해야 한다.” |

---

> 🧠 **시험 포인트 정리**
>
> 1. 본질식별자 = 업무 존재 / 인조식별자 = 인위 생성
> 2. 인조식별자는 보통 복합식별자 단순화할 때 사용
> 3. 인조식별자 장점 → 개발 편의성 / 단점 → 중복 가능성
> 4. 본질식별자 사용 시 무결성 유지, 인덱스 자동 생성
> 5. 인조식별자 선택 시 “비용·성능·무결성” 균형 고려

---
